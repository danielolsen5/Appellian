import numpy as np
import matplotlib.pyplot as plt

"""
Joukowski Airfoil Generation
"""

# --- CONFIGURATION ---
Debug = False       # Toggle debug outputs
Plot = True         # Toggle plotting
Export = False      # Toggle export to file
Number = False      # Toggle printing point indices on plot
Curvature = False   # Toggle curvature calculation/plotting

# Point Distribution Settings
n_upper = 112       # Points on upper surface
n_lower = 88       # Points on lower surface

# Clustering Settings
# 1: No clustering (Uniform)
# 2: Cosine clustering 
clustering_method = 2 

# Smoothing Factor (0.0 to 1.0)
smoothing_factor = 0.6

# Geometry Parameters
R = 1.0       # Radius of cylinder
xi0 = -0.109  # Real center "x" (thickness)
eta0 = 0.2    # Imaginary center "y" (camber)
eps = R - np.sqrt(R**2 - eta0**2) - xi0 # Eccentricity (TE sharpness)
V_inf = 10    # Freestream velocity 
alpha = np.radians(0) # Angle of attack

# --- AERODYNAMIC CALCULATIONS ---
gamma_k = 4 * np.pi * V_inf * (np.sqrt(R**2 - eta0**2)*np.sin(alpha) + eta0*np.cos(alpha))

if abs(gamma_k) <= (4 * np.pi * V_inf * R):
    theta_stag_aft = alpha - np.arcsin(gamma_k / (4 * np.pi * V_inf * R))
    theta_stag_fwd = np.pi - theta_stag_aft + 2 * alpha
else:
    theta_stag_fwd = alpha - np.arcsin(gamma_k / (4 * np.pi * V_inf * R))
    theta_stag_aft = np.pi - theta_stag_fwd + 2 * alpha


# --- MAIN TRANSFORM FUNCTION ---
def transform_joukowski_cylinder(n_up, n_lo, R, xi0, eta0, eps, 
                                 method=2, smoothing=0.0):
    
    # Cylinder Center
    zeta_0 = xi0 + 1j * eta0
    
    # Cylinder Intercepts
    xl = xi0 - np.sqrt(R**2 - eta0**2) 
    xt = xi0 + np.sqrt(R**2 - eta0**2) 
    
    # Geometric Angles for Leading Edge (LE) and Trailing Edge (TE)
    theta_le = np.pi - np.arcsin(eta0/(xl - xi0)) 
    theta_te = -np.arcsin(-eta0/(xi0 -  xt)) 
    
    if Debug:
        print(f"Target LE Angle: {np.degrees(theta_le):.2f}°")
        print(f"Target TE Angle: {np.degrees(theta_te):.2f}°")
    
    # --- DISTRIBUTION GENERATOR ---
    def get_distribution(num_points, method_type, w_smooth):
        # 1. Base Uniform Vector (0 to pi)
        beta = np.linspace(0, np.pi, num_points + 1)
        
        # 2. Calculate Pure Distribution
        if method_type == 1: # UNIFORM
            d_pure = beta / np.pi
            
        elif method_type == 2: # COSINE
            d_pure = (1 - np.cos(beta)) / 2
            
        else: # Default to uniform if unknown
            print("Unknown method. Defaulting to Uniform.")
            d_pure = beta / np.pi
            
        # 3. Calculate Uniform Distribution (for blending)
        d_uniform = beta / np.pi
        
        # 4. Apply Smoothing (Blending)
        # w_smooth = 0.0 -> Pure Cosine
        # w_smooth = 1.0 -> Pure Uniform
        d_final = (1 - w_smooth) * d_pure + w_smooth * d_uniform
        
        return d_final

    # Calculate Upper and Lower distributions independently
    dist_upper = get_distribution(n_up, method, smoothing)
    dist_lower = get_distribution(n_lo, method, smoothing)

    # --- MAPPING ---
    # Segment 1: Upper Surface (TE -> LE)
    theta_upper = theta_te + (theta_le - theta_te) * dist_upper
    
    # Segment 2: Lower Surface (LE -> TE) 
    theta_lower = theta_le + (theta_te + 2*np.pi - theta_le) * dist_lower
    
    # Combine (Drop duplicate LE point from upper)
    theta = np.concatenate((theta_upper[:-1], theta_lower))
    
    # Generate Cylinder Surface
    zeta_surface = R * np.exp(1j * theta) + zeta_0
    
    # Joukowski Transform
    z_surface = zeta_surface + (R - eps)**2 / zeta_surface
    
    return zeta_surface, z_surface


# --- EXECUTION ---

# 1. Generate Raw Coordinates
zeta_surf, z_surf = transform_joukowski_cylinder(
    n_upper, n_lower, R, xi0, eta0, eps, 
    method=clustering_method, 
    smoothing=smoothing_factor
)

# 2. Extract and Normalize
z_real_raw = z_surf.real
z_imag_raw = z_surf.imag

# Shift LE to (0,0)
x_min = np.min(z_real_raw)
if x_min < 0:
    z_real_shifted = z_real_raw + abs(x_min)
else:
    z_real_shifted = z_real_raw - abs(x_min)

# Scale Chord to 1.0
chord_scale = 1.0 / np.max(z_real_shifted)
z_real = z_real_shifted[::-1] * chord_scale # Flip to clockwise
z_imag = z_imag_raw[::-1] * chord_scale     # Flip to clockwise

if Debug:
    print(f"Total Points: {len(z_real)}")
    print(f"Chord Scale: {chord_scale:.4f}")

# --- DISTANCE ANALYSIS ---
def get_panel_spacing(x, y):
    dx = x[1:] - x[:-1]
    dy = y[1:] - y[:-1]
    return np.sqrt(dx**2 + dy**2)

ds = get_panel_spacing(z_real, z_imag)
s_arc = np.concatenate(([0], np.cumsum(ds)))

# --- PLOTTING ---
if Plot:
    fig = plt.figure(figsize=(12, 8))
    
    # Subplot 1: The Airfoil Shape
    ax1 = fig.add_subplot(2, 1, 1)
    label_txt = f"Joukowski (Up:{n_upper}, Low:{n_lower})\nMethod: {clustering_method}, Smooth: {smoothing_factor}"
    ax1.plot(z_real, z_imag, 'b-', label='Surface')
    ax1.scatter(z_real, z_imag, color='b', s=10, label='Nodes')
    
    if Number:
        for i, (xr, yr) in enumerate(zip(z_real, z_imag)):
            if i % 20 == 0: 
                ax1.text(xr, yr, str(i), fontsize=8, color='red')
                
    ax1.set_title(label_txt)
    ax1.set_xlabel("x/c")
    ax1.set_ylabel("y/c")
    ax1.axis('equal')
    ax1.grid(True, linestyle=':', alpha=0.6)
    ax1.legend()

    # Subplot 2: Panel Spacing (The "V" vs "U" check)
    ax2 = fig.add_subplot(2, 1, 2)
    ax2.plot(range(len(ds)), ds, '.-', color='darkorange')
    ax2.set_title("Panel Spacing (Local Distance between points)")
    ax2.set_xlabel("Point Index (TE -> LE -> TE)")
    ax2.set_ylabel("Distance (ds)")
    ax2.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.show()

# --- EXPORT ---
if Export:
    np.savetxt("output.txt", np.column_stack((z_real, z_imag)), fmt="%.6f")
    print("Coordinates exported to output.txt")

# --- CURVATURE  ---
if Curvature:
    # Osculating Circle Curvature implementation
    def calc_curvature(x, y):
        k = []
        n_pts = len(x)
        # check 3 points avsilable 
        if n_pts < 3: return np.zeros(n_pts)
        
        for i in range(n_pts - 2):
            p0 = np.array([x[i], y[i]])
            p1 = np.array([x[i+1], y[i+1]])
            p2 = np.array([x[i+2], y[i+2]])
            
            # Midpoints
            m1 = (p0 + p1)/2
            m2 = (p1 + p2)/2
            
            # Perpendicular vectors
            v1 = p1 - p0; n1 = np.array([-v1[1], v1[0]])
            v2 = p2 - p1; n2 = np.array([-v2[1], v2[0]]) # Fixed vector logic
            
            # Intersect
            A = np.column_stack((n1, -n2))
            b = m2 - m1
            try:
                t = np.linalg.solve(A, b)
                center = m1 + t[0]*n1
                r = np.linalg.norm(center - p1)
                k.append(1.0/r if r > 1e-6 else 0)
            except:
                k.append(0)
        return np.array(k)

    k_vals = calc_curvature(z_real, z_imag)
    
    plt.figure()
    plt.plot(k_vals)
    plt.title("Curvature Estimation")
    plt.xlabel("Index")
    plt.ylabel("Curvature (1/R)")
    plt.show()