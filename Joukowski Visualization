import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize_scalar

"""
Joukowski Airfoil Generation
"""

# --- CONFIGURATION ---
Debug = False       # Toggle debug outputs
Plot = True         # Toggle plotting
Export = False      # Toggle export to file
Number = False      # Toggle printing point indices on plot
Curvature = True   # Toggle curvature calculation/plotting

# Clustering Settings
# 1: No clustering (Uniform)
# 2: Cosine clustering 
clustering_method = 2 

# Smoothing Factor (0.0 to 1.0)
smoothing_factor = .6

# Geometry Parameters
n = 400 # number of points
rho = 1.225 # density
R = 1.0       # Radius of cylinder
xi0 = -0.10  # Real center "x" (thickness)
eta0 = 0.2   # Imaginary center "y" (camber)
eps = R - np.sqrt(R**2 - eta0**2) - xi0 # Eccentricity (TE sharpness)
V_inf = 10    # Freestream velocity 
alpha = np.radians(0) # Angle of attack

# Geometric Angles for Leading Edge (LE) and Trailing Edge (TE)
xl = xi0 - np.sqrt(R**2 - eta0**2) 
xt = xi0 + np.sqrt(R**2 - eta0**2) 
theta_le = np.pi - np.arcsin(eta0/(xl - xi0)) 
theta_te = -np.arcsin(-eta0/(xi0 -  xt)) 

# Point Distribution Settings
l_u = R * np.abs((theta_le-theta_te)) # length of upper surface in zeta plane
l_t = np.pi * 2 * R # circumfrance in zeta
p_u = l_u/l_t
n_upper = p_u * n # scale number of points on the upper surface with its length
n_upper = round(n_upper) # force n_upper to be a whole number
n_lower = n - n_upper # Points on lower surface

# --- AERODYNAMIC CALCULATIONS ---
gamma_k = 4 * np.pi * V_inf * (np.sqrt(R**2 - eta0**2)*np.sin(alpha) + eta0*np.cos(alpha))

if abs(gamma_k) <= (4 * np.pi * V_inf * R):
    theta_stag_aft = alpha - np.arcsin(gamma_k / (4 * np.pi * V_inf * R))
    theta_stag_fwd = np.pi - theta_stag_aft + 2 * alpha
else:
    theta_stag_fwd = alpha - np.arcsin(gamma_k / (4 * np.pi * V_inf * R))
    theta_stag_aft = np.pi - theta_stag_fwd + 2 * alpha

# --- MAIN TRANSFORM FUNCTION ---
def transform_joukowski_cylinder(n_up, n_lo, R, xi0, eta0, eps, 
                                 method=2, smoothing=0.0):
    # Cylinder Center
    zeta_0 = xi0 + 1j * eta0
    
    # Geometric Angles for Leading Edge (LE) and Trailing Edge (TE)
    theta_le = np.pi - np.arcsin(eta0/(xl - xi0)) 
    theta_te = -np.arcsin(-eta0/(xi0 -  xt)) 
    
    # --- DISTRIBUTION GENERATOR ---
    def get_distribution(num_points, method_type, w_smooth):
        # 1. Base Uniform Vector (0 to pi)
        beta = np.linspace(0, np.pi, num_points + 1)
        
        # 2. Calculate Pure Distribution
        if method_type == 1: # UNIFORM
            d_pure = beta / np.pi
            
        elif method_type == 2: # COSINE
            d_pure = (1 - np.cos(beta)) / 2
            
        else: # Default to uniform if unknown
            print("Unknown method. Defaulting to Uniform.")
            d_pure = beta / np.pi
            
        # 3. Calculate Uniform Distribution (for blending)
        d_uniform = beta / np.pi
        
        # 4. Apply Smoothing (Blending)
        # w_smooth = 0.0 -> Pure Cosine
        # w_smooth = 1.0 -> Pure Uniform
        d_final = (1 - w_smooth) * d_pure + w_smooth * d_uniform
        
        return d_final

    # Calculate Upper and Lower distributions independently
    dist_upper = get_distribution(n_up, method, smoothing)
    dist_lower = get_distribution(n_lo, method, smoothing)

    # --- MAPPING ---
    # Segment 1: Upper Surface (TE -> LE)
    theta_upper = theta_te + (theta_le - theta_te) * dist_upper
    
    # Segment 2: Lower Surface (LE -> TE) 
    theta_lower = theta_le + (theta_te + 2*np.pi - theta_le) * dist_lower
    
    # Combine (Drop duplicate LE point from upper)
    theta = np.concatenate((theta_upper[:-1], theta_lower))
    
    # Generate Cylinder Surface
    zeta_surface = R * np.exp(1j * theta) + zeta_0
    
    # Joukowski Transform
    z_surface = zeta_surface + (R - eps)**2 / zeta_surface
    
    return zeta_surface, z_surface


# --- EXECUTION ---

# 1. Generate Raw Coordinates
zeta_surf, z_surf = transform_joukowski_cylinder(
    n_upper, n_lower, R, xi0, eta0, eps, 
    method=clustering_method, 
    smoothing=smoothing_factor
)

# 2. Extract and Normalize
z_real_raw = z_surf.real
z_imag_raw = z_surf.imag

# Shift LE to (0,0)
x_min = np.min(z_real_raw)
if x_min < 0:
    z_real_shifted = z_real_raw + abs(x_min)
else:
    z_real_shifted = z_real_raw - abs(x_min)

# Scale Chord to 1.0
chord_scale = 1.0 / np.max(z_real_shifted)
z_real = z_real_shifted[::-1] * chord_scale # Flip to clockwise
z_imag = z_imag_raw[::-1] * chord_scale     # Flip to clockwise

#leading edge point
z_le_r = z_real[n_lower]
z_le_i = z_imag[n_lower]


if Debug:
    print(f"Total Points: {len(z_real)}")
    print(f"Chord Scale: {chord_scale:.4f}")

# --- DISTANCE ANALYSIS ---
def get_panel_spacing(x, y):
    dx = x[1:] - x[:-1]
    dy = y[1:] - y[:-1]
    return np.sqrt(dx**2 + dy**2)

ds = get_panel_spacing(z_real, z_imag)
s_arc = np.concatenate(([0], np.cumsum(ds)))

# --- PLOTTING ---
if Plot:
    fig = plt.figure(figsize=(12, 8))
    
    # Subplot 1: The Airfoil Shape
    ax1 = fig.add_subplot(2, 1, 1)
    label_txt = f"Joukowski (Up:{n_upper}, Low:{n_lower})\nMethod: {clustering_method}, Smooth: {smoothing_factor}"
    ax1.plot(z_real, z_imag, 'b-', label='Surface')
    ax1.scatter(z_le_r, z_le_i, color='r', s=40, label='Leading Edge')
    ax1.scatter(z_real, z_imag, color='b', s=10, label='Nodes')
    
    if Number:
        for i, (xr, yr) in enumerate(zip(z_real, z_imag)):
            if i % 20 == 0: 
                ax1.text(xr, yr, str(i), fontsize=8, color='red')
                
    ax1.set_title(label_txt)
    ax1.set_xlabel("x/c")
    ax1.set_ylabel("y/c")
    ax1.axis('equal')
    ax1.grid(True, linestyle=':', alpha=0.6)
    ax1.legend()

    # Subplot 2: Panel Spacing (The "V" vs "U" check)
    ax2 = fig.add_subplot(2, 1, 2)
    ax2.plot(range(len(ds)), ds, '.-', color='darkorange')
    ax2.set_title("Panel Spacing (Local Distance between points)")
    ax2.set_xlabel("Point Index (TE -> LE -> TE)")
    ax2.set_ylabel("Distance (ds)")
    ax2.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.show()

# --- EXPORT ---
if Export:
    np.savetxt("output.txt", np.column_stack((z_real, z_imag)), fmt="%.6f")
    print("Coordinates exported to output.txt")

# --- CURVATURE  ---

if Curvature:
    def get_point_at_theta(t):
        """Helper to get a single (x, y) point for a given theta."""
        zeta = R * np.exp(1j * t) + (xi0 + 1j * eta0)
        z = zeta + (R - eps)**2 / zeta
        # Normalize/Scale as per your main script
        x = (z.real + abs(x_min)) * chord_scale
        y = z.imag * chord_scale
        return x, y

    def curvature_at_theta(t):
        """
        Calculates exact curvature at any angle theta using 1st and 2nd derivatives.
        Formula: k = |x'y'' - y'x''| / (x'^2 + y'^2)^(3/2)
        """
        dt = 1e-5 # Small step for finite difference
        
        # Central difference for derivatives
        p_m1 = get_point_at_theta(t - dt)
        p_0  = get_point_at_theta(t)
        p_p1 = get_point_at_theta(t + dt)
        
        dx = (p_p1[0] - p_m1[0]) / (2 * dt)
        dy = (p_p1[1] - p_m1[1]) / (2 * dt)
        
        d2x = (p_p1[0] - 2*p_0[0] + p_m1[0]) / (dt**2)
        d2y = (p_p1[1] - 2*p_0[1] + p_m1[1]) / (dt**2)
        
        num = np.abs(dx * d2y - dy * d2x)
        den = (dx**2 + dy**2)**(1.5)
        
        return num / den if den > 1e-9 else 0

    # 1. Initial Search: Find index of max discrete curvature
    # Re-using your k_vals logic
    def calc_curvature(x, y):
        # ... (Your existing osculating circle code here) ...
        # [Keeping it brief for the snippet]
        pass 

    # 2. Iterative Process (Optimization)
    # We target the Leading Edge area: theta is near pi
    # Minimize the negative curvature to find the maximum
    result = minimize_scalar(lambda t: -curvature_at_theta(t), 
                             bounds=(np.pi - 0.5, np.pi + 0.5), 
                             method='bounded')
    
    true_theta_max = result.x
    true_k_max = -result.fun
    true_x, true_y = get_point_at_theta(true_theta_max)

    print("-" * 30)
    print("ITERATIVE CURVATURE ANALYSIS")
    print(f"Max Curvature: {true_k_max:.4f}")
    print(f"True LE Location: x={true_x:.6f}, y={true_y:.6f}")
    print(f"Optimal Theta: {true_theta_max:.6f} rad")
    print("-" * 30)

    # --- PLOTTING REFINEMENT ---
    plt.figure(figsize=(8, 4))
    # Plot a range of theta around the peak to see the curve
    t_fine = np.linspace(true_theta_max - 0.1, true_theta_max + 0.1, 100)
    k_fine = [curvature_at_theta(ti) for ti in t_fine]
    
    plt.plot(t_fine, k_fine, 'g-', label='Continuous Curvature')
    plt.plot(true_theta_max, true_k_max, 'ro', label='Iterative Max')
    plt.title("Iterative Refinement of Max Curvature")
    plt.xlabel("Theta (radians)")
    plt.ylabel("Curvature")
    plt.legend()
    plt.grid(True)
    plt.show()
    
    from scipy.integrate import quad

def arc_length_integrand(t):
    dt = 1e-6
    p_m1 = get_point_at_theta(t - dt)
    p_p1 = get_point_at_theta(t + dt)
    
    # Derivatives dx/dt and dy/dt
    dx_dt = (p_p1[0] - p_m1[0]) / (2 * dt)
    dy_dt = (p_p1[1] - p_m1[1]) / (2 * dt)
    
    return np.sqrt(dx_dt**2 + dy_dt**2)

# Calculate true lengths using integration
# Note: theta_te to theta_le is upper, theta_le to theta_te+2pi is lower
true_len_upper, _ = quad(arc_length_integrand, theta_te, theta_le)
true_len_lower, _ = quad(arc_length_integrand, theta_le, theta_te + 2*np.pi)

print(f"True Upper Surface Length: {true_len_upper:.6f}")
print(f"True Lower Surface Length: {true_len_lower:.6f}")


def fit_camber():
    #define leading edge point
    #define trailing edge point
    #find midpoint of flat "camber" line
    #find midpoint of airfoil thickness 
    #fit circular arc through points
    