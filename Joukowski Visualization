import numpy as np
import matplotlib.pyplot as plt

"""
Joukowski airfoil generation

"""

Debug = False #toggle debug outputs
Plot = True #toggle plotting airfoils
Export = False #toggle export file

n = 200  # Number of points 
R = 1.0  # Radius of the circular cylinder in the zeta plane
xi0 = -0.09 # Real center "x"  drives thickness
eta0 = 0.1 # Imaginary center "y" drives camber/symetry 
eps = R - np.sqrt(R**2 - eta0**2) - xi0 # Eccentricity parameter  drives trailing edge sharpness
V_inf = 10          # freestream velocity 
a = np.radians(0)

gamma_k = 4 * np.pi * V_inf * (np.sqrt(R**2 - eta0**2)*np.sin(a) + eta0*np.cos(a)) #Kutta circulation Eq 45

if abs(gamma_k) <= (4 * np.pi * V_inf * R):
    theta_stag_aft = a - np.arcsin(gamma_k / (4 * np.pi * V_inf * R))
    theta_stag_fwd = np.pi - theta_stag_aft + 2 * a
else:
    theta_stag_fwd = a - np.arcsin(gamma_k / (4 * np.pi * V_inf * R))
    theta_stag_aft = np.pi - theta_stag_fwd + 2 * a

xi_stag_aft = R * np.exp(1j * theta_stag_aft) + xi0
xi_stag_fwd = R * np.exp(1j * theta_stag_fwd) + xi0

def transform_joukowski_cylinder(n, R, xi0, eta0, eps, theta_stag_aft):
    
    # Define the center of the circular cylinder in the ζ-plane (Eq. 19)
    zeta_0 = xi0 + 1j * eta0
    
    # Create an array of angles (θ) to parameterize the circle
    theta = np.linspace(0, 2*np.pi, n)
    theta = theta + theta_stag_aft

    # Define the surface of the circular cylinder in the ζ-plane (Eq. 20)
    zeta_surface = R * np.exp(1j * theta) + zeta_0
    
    # Apply the Joukowski transformation to the surface points (Eq. 18)
    z_surface = zeta_surface + (R - eps)**2 / zeta_surface
    
    return zeta_surface, z_surface

# Perform the transformation
zeta_surface, z_surface = transform_joukowski_cylinder(n, R, xi0, eta0, eps, theta_stag_aft)

# Separate real and imaginary parts for analysis or plotting
z_real_0 = z_surface.real
z_imag_0 = z_surface.imag

# Shift leading edge to origin
x_max = np.max(z_real_0) #maximum "x" value
x_min = np.min(z_real_0) #minimum "x" vlaue

offset = x_min

if offset < 0:
    z_real_t =  z_real_0 + abs(offset)
else:
    z_real_t = z_real_0 - abs(offset)

# scale chord length to 1
chord_scale = 1 / np.max(z_real_t)

z_real_f = chord_scale * z_real_t
z_imag_f = chord_scale * z_imag_0

# flip vlaues to follow clockwise convention 
z_real = z_real_f[::-1]
z_imag = z_imag_f[::-1]


if Debug:
    print("X min ", x_min)
    print("X max", x_max)
    print("chord scale: ", chord_scale)
    print("Original Coordinates", zeta_surface)
    print("Transformed Real Components (z_real):\n", z_real)
    print("\nTransformed Imaginary Components (z_imag_0):\n", z_imag)

if Plot:
    #Visualization
    fig, ax = plt.subplots()

    # Cylinder in ζ-plane
    ax.plot(zeta_surface.real, zeta_surface.imag, 'r', label='Cylinder (ζ-plane)')

    # Transformed airfoil in z-plane
    ax.plot(z_real_0, z_imag_0, 'b', label='Joukowski Airfoil (z-plane)')

    # scaled airfoil in z-plane
    ax.plot(z_real, z_imag, 'c', label='scaled Airfoil (z-plane)')

    ax.set_title('Cylinder and Joukowski Airfoil')
    ax.set_xlabel('Real Part')
    ax.set_ylabel('Imaginary Part')
    ax.set_aspect('equal', adjustable='box')
    ax.legend()
    plt.show()
    
    #output txt file 
    
    if Export:
        np.savetxt("output.txt", np.column_stack((z_real, z_imag)), fmt="%.6f")
    
    """
    Define curvature along the airfoil
    """
#define curvature with quadratic
def quad_curvature(z_real, z_imag, n):
    k = np.zeros(n-2)
    for i in range(n-2):

        # define C with imag values
        C = np.array([[z_imag[i]],
                      [z_imag[i+1]],
                      [z_imag[i+2]]])
            
        #build A with real values
        A = np.array([[z_real[i]**2, z_real[i], 1],
                      [z_real[i+1]**2, z_real[i+1], 1],
                      [z_real[i+2]**2, z_real[i+2], 1]])
            
        # invert A 
        A_inv = np.linalg.inv(A)
        #solve for quadratic constants 
        B = np.linalg.solve(A_inv, C)

        # first derivative of quadratic
        d1 = (2*B[0]*z_real[i+1]) + B[1]
        # second derivative of quadratic
        d2 = 2 * B[0]
        #calculate curvature 
        k[i] += np.abs(d2) / ((1 + d1**2)**(2/3))

    return k
    
k = quad_curvature(z_real, z_imag, n)
# plot curvature

fig, ax = plt.subplots()
ax.plot(range(len(k)), k, label='quadratic curvature')
ax.set_title('Quadratic Arifoil Curvature')
ax.set_xlabel('Distance Along Curve')
ax.set_ylabel('Curvature')
plt.show()

#define curvature with osculating circles
def circle_curvature(z_real, z_imag):
    
    dx = z_real[1:] - z_real[:-1]
    dy = z_imag[1:] - z_imag[:-1]
    l  = np.sqrt(dx**2 + dy**2)

    for i in range(n): 
        p0 = np.array([[z_real[i]],
                       [z_imag[i]]])
        
        p1 = np.array([[z_real[i+1]],
                       [z_imag[i+1]]])
        
        p2 = np.array([[z_real[i+2]],
                       [z_imag[i+2]]])
        
        #find midpoint between point 0 and 1
        m1 = (p0 + p1)/2

        #find midpoint between point 1 and 2
        m2 = (p1 + p2)/2

        # direction between points
        v1 = p1 - p0
        v2 = p2 - p0

        # outward normal vector at each midpoint
        n1 = np.array([v1[1], v1[0]])
        n2 = np.array([v1[1], v1[0]])
        
        #find interscetion of each normal vector

        # find radius 
        r = np.abs(c - p1)
        #calculate curvature
        k = 1/ r