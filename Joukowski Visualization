import numpy as np
import matplotlib.pyplot as plt

"""
Joukowski airfoil generation

"""

Debug = False #toggle debug outputs
Plot = False #toggle plotting airfoils
Export = False #toggle export file
number = False # toggle printing the position of each airfoil point
curveature = False

n = 200  # Number of points 
R = 1.0  # Radius of the circular cylinder in the zeta plane
xi0 = -0.09 # Real center "x"  drives thickness
eta0 = 0.1 # Imaginary center "y" drives camber/symetry 
eps = R - np.sqrt(R**2 - eta0**2) - xi0 # Eccentricity parameter  drives trailing edge sharpness
V_inf = 10          # freestream velocity 
a = np.radians(0)

gamma_k = 4 * np.pi * V_inf * (np.sqrt(R**2 - eta0**2)*np.sin(a) + eta0*np.cos(a)) #Kutta circulation Eq 45

if abs(gamma_k) <= (4 * np.pi * V_inf * R):
    theta_stag_aft = a - np.arcsin(gamma_k / (4 * np.pi * V_inf * R))
    theta_stag_fwd = np.pi - theta_stag_aft + 2 * a
else:
    theta_stag_fwd = a - np.arcsin(gamma_k / (4 * np.pi * V_inf * R))
    theta_stag_aft = np.pi - theta_stag_fwd + 2 * a

xi_stag_aft = R * np.exp(1j * theta_stag_aft) + xi0
xi_stag_fwd = R * np.exp(1j * theta_stag_fwd) + xi0
 


def transform_joukowski_cylinder(n, R, xi0, eta0, eps, theta_stag_aft):
    
    # Define the center of the circular cylinder in the ζ-plane (Eq. 19)
    zeta_0 = xi0 + 1j * eta0
    
    # Find x intercept of the cylinder in the zeta plane
    xl = xi0 - np.sqrt(R**2 - eta0**2) 
    xt = xi0 + np.sqrt(R**2 - eta0**2) 
    
    theta_le = np.pi - np.arcsin(eta0/(xl - xi0)) # theta at leading edge
    theta_te = -np.arcsin(-eta0/(xi0 -  xt)) # theta at trailing edge 
    
    print(np.degrees(theta_le))
    print(np.degrees(theta_te))
    
    # Generate theta distribution (0 to 2π)
    theta = np.linspace(0, 2 * np.pi, n)
    
    zeta_surface = R * np.exp(1j * theta) + zeta_0
    
    # Apply the Joukowski transformation to the surface points (Eq. 18)
    z_surface = zeta_surface + (R - eps)**2 / zeta_surface
    
    return zeta_surface, z_surface

# Perform the transformation
zeta_surface, z_surface = transform_joukowski_cylinder(n, R, xi0, eta0, eps, theta_stag_aft) 

# Separate real and imaginary parts
z_real_0 = z_surface.real
z_imag_0 = z_surface.imag
zeta_real = zeta_surface.real
zeta_imag = zeta_surface.imag

# Shift leading edge to origin
x_max = np.max(z_real_0) #maximum "x" value
x_min = np.min(z_real_0) #minimum "x" vlaue

offset = x_min

if offset < 0:
    z_real_t =  z_real_0 + abs(offset)
else:
    z_real_t = z_real_0 - abs(offset)

# scale chord length to 1
chord_scale = 1 / np.max(z_real_t)

# flip vlaues to follow clockwise convention 
z_real_f = z_real_t[::-1]
z_imag_f = z_imag_0[::-1]

#scale for chord of 1
z_real = chord_scale * z_real_f
z_imag = chord_scale * z_imag_f


if Debug:
    print("X min ", x_min)
    print("X max", x_max)
    print("chord scale: ", chord_scale)
    print("Original Coordinates", zeta_surface)
    print("Transformed Real Components (z_real):\n", z_real)
    print("\nTransformed Imaginary Components (z_imag_0):\n", z_imag)

if Plot:
    #Visualization
    fig, ax = plt.subplots()

    # Cylinder in ζ-plane
    zeta_r = zeta_surface.real
    zeta_i = zeta_surface.imag
    ax.plot(zeta_r, zeta_i, 'r', label='Cylinder (ζ-plane)')
    if number:
        #plot array position by point 

        for i, (zeta_ri, zeta_ii) in enumerate(zip(zeta_r, zeta_i)):
            if i % 25 == 0:
                plt.text(zeta_ri, zeta_ii, f'{i}', fontsize=9, ha='left', va='bottom')

    # Transformed airfoil in z-plane
    ax.plot(z_real_0, z_imag_0, 'b', label='Joukowski Airfoil (z-plane)')

    # scaled airfoil in z-plane
    ax.plot(z_real, z_imag, 'c', label='scaled Airfoil (z-plane)')
    if number:
        #plot array position by point 

        for i, (z_reali, z_imagi) in enumerate(zip(z_real, z_imag)):
            if i % 25 == 0:
                plt.text(z_reali, z_imagi, f'{i}', fontsize=9, ha='left', va='bottom')

    ax.plot()

    ax.set_title('Cylinder and Joukowski Airfoil')
    ax.set_xlabel('Real Part')
    ax.set_ylabel('Imaginary Part')
    ax.set_aspect('equal', adjustable='box')
    #ax.legend()
    plt.show()
    
    #output txt file 
    
    if Export:
        np.savetxt("output.txt", np.column_stack((z_real, z_imag)), fmt="%.6f")
    
    """
    Define curvature along the airfoil
    """
if curveature:
#define curvature with quadratic
    def quad_curvature(z_real_0, z_imag_0, n):
        k = np.zeros(n-2)
        for i in range(n-2):

            # define C with imag values
            C = np.array([[z_imag_0[i]],
                        [z_imag_0[i+1]],
                        [z_imag_0[i+2]]])
            
        #build A with real values
            A = np.array([[z_real_0[i]**2, z_real_0[i], 1],
                        [z_real_0[i+1]**2, z_real_0[i+1], 1],
                        [z_real_0[i+2]**2, z_real_0[i+2], 1]])
            
        # invert A 
            A_inv = np.linalg.inv(A)
        #solve for quadratic constants 
            B = np.linalg.solve(A_inv, C)

        # first derivative of quadratic
            d1 = (2*B[0]*z_real[i+1]) + B[1]
        # second derivative of quadratic
            d2 = 2 * B[0]
        #calculate curvature 
            k[i] += np.abs(d2) / ((1 + d1**2)**(2/3))

        return k
    
    kq = 1 / quad_curvature(z_real_0, z_imag_0, n)
# plot curvature

    fig, ax = plt.subplots()
    ax.plot(range(len(kq)), kq, label='quadratic curvature')
    ax.set_title('Quadratic Arifoil Curvature')
    ax.set_xlabel('Distance Along Curve')
    ax.set_ylabel('Curvature')
    plt.show()

#define curvature with osculating circles
    def circle_curvature(z_real_0, z_imag_0):
        n = len(z_real)
        kc = []
        dx = z_real_0[1:] - z_real_0[:-1]
        dy = z_imag_0[1:] - z_imag_0[:-1]
        l  = np.sqrt(dx**2 + dy**2)

        for i in range(n-10): 
            p0 = np.array([z_real_0[i], z_imag_0[i]])
            p1 = np.array([z_real_0[i + 1], z_imag_0[i + 1]])
            p2 = np.array([z_real_0[i + 2], z_imag_0[i + 2]])
        
        #find midpoint between point 0 and 1
            m1 = (p0 + p1)/2

        #find midpoint between point 1 and 2
            m2 = (p1 + p2)/2

        # direction between points
            v1 = p1 - p0
            v2 = p2 - p0

        # outward normal vector at each midpoint
            n1 = np.array([-v1[1], v1[0]])
            n2 = np.array([-v2[1], v2[0]])
        
        #find intersection
            A = np.column_stack((n1, -n2))
            b = m2 - m1

            try:
                t = np.linalg.solve(A, b)
            except np.linalg.LinAlgError:
                kc.append(0)
                continue

            c = m1 + t[0] * n1 #center

            r = np.linalg.norm(c - p1)
            if r == 0:
                kc.append(0)
            else:
                kc.append(1/r)

        return kc

    kc = circle_curvature(z_real_0, z_imag_0)
    maxk = np.argmax(kc)
    print("Leading Edge Location", maxk)

    print(f"leading Edge Coordinate in zeta plane: ({zeta_real[maxk]:.4f}, {zeta_imag[maxk]:.4f})")
    theta_le = np.arctan((zeta_imag[maxk] - eta0)/(zeta_real[maxk] - xi0))
    print("theta to leading edge: ", np.degrees(theta_le))

    fig, ax = plt.subplots()
    ax.plot(range(len(kc)), kc, label='Osculating Circles Curvature')
    ax.set_title('Osculating Circles Arifoil Curvature')
    ax.set_xlabel('Distance Along Curve')
    ax.set_ylabel('Curvature')
    plt.show()

"""
clustering    
"""

def distance(z_real_f, z_imag_f, n):
    z_real_f = np.asarray(z_real_f)
    z_imag_f = np.asarray(z_imag_f)

    dx = z_real_f[1:] - z_real_f[:-1]
    dy = z_imag_f[1:] - z_imag_f[:-1]

    d = np.sqrt(dx**2 + dy**2)
    return d

d = distance(z_real_f, z_imag_f, n)

fig, ax = plt.subplots()
ax.plot(range(len(d)), d, label='distance between points')
ax.set_title('Osculating Circles Arifoil Curvature')
ax.set_xlabel('Distance Along Curve')
ax.set_ylabel('distance between points')
plt.show()