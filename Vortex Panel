import json
import numpy as np
import matplotlib.pyplot as plt
import os
from matplotlib.path import Path

# === DEBUG TOGGLE ===
DEBUG = False

# Global variables
V_inf = 20.0             # freestream velocity magnitude
a_deg = 0.0              # angle alpha in deg
a = np.radians(a_deg)
P_inf = 101325.0         # free stream pressure Pa
rho = 1.225              # air density kg/m^3
c = 1.0                  # chord length

# Read geometry from JSON
filename = "json_input.json"
with open(filename, "r") as fh:
    input_dict = json.load(fh)

NACAfile = input_dict["geometry"]
info = []
with open(NACAfile, "r") as f:
    for line in f:
        if line.strip() == "":
            continue
        parts = line.split()
        if len(parts) < 2:
            continue
        info.append([float(parts[0]), float(parts[1])])

info = np.array(info)
x_input = info[:, 0]
y_input = info[:, 1]

# geometry
x = x_input
y = y_input
n = len(x)
n_pan = n - 1


"""
VPM Formulation
"""
#panel lengths 
dx = x[1:] - x[:-1]
dy = y[1:] - y[:-1]
l  = np.sqrt(dx**2 + dy**2)

# B
B = V_inf * ((dy * np.cos(a)) - (dx * np.sin(a))) / l
B = np.append(B, 0)

# control points
xc = 0.5 * (x[:-1] + x[1:])
yc = 0.5 * (y[:-1] + y[1:])
if DEBUG:
    print("xc:", xc)
    print("yc:", yc)

# build A 1.6.25
def build_A(x, y, xc, yc, dx, dy, l, DEBUG=False):
    n_pan = len(dx)
    A = np.zeros((n, n), dtype=float)
    eps = 1e-15

    for i in range(n-1):
        
        # outward unit normal at control point i 
        nx = dx[i] / l[i]
        ny = -dy[i] / l[i]

        for j in range(n-1):
            dxj = dx[j]; dyj = dy[j]; lj = l[j]

            #1.6.20  xi, eta in panel-j coordinates
            # use panel j to build the local frame 
            M = np.array([[dxj,  dyj],
                           [-dyj, dxj]])   # transform for panel j

            #1.6.20
            # vector from panel-j start to control point i
            N = np.array([xc[i] - x[j], yc[i] - y[j]])

            xi_eta = (1.0 / lj) * M.dot(N)   # [xi, eta]
            xi = float(xi_eta[0])
            eta = float(xi_eta[1])

            # phi 1.6.21
            phi = np.arctan2(eta * lj, (eta**2 + xi**2 - xi * lj))
            
            # psi 1.6.22
            num = xi**2 + eta**2
            den = (xi - lj)**2 + eta**2
            psi = 0.5 * np.log(num / (den ))

            # P 1.6.23
            W = np.array([
                [(lj - xi) * phi + (eta * psi),       xi * phi - eta * psi],
                [eta * phi - (lj - xi) * psi - lj,  -eta * phi - xi * psi + lj]
            ])
            
            V = np.array([[dxj,  -dyj],
                           [dyj, dxj]])

            # P 
            P = (1.0 / (2.0 * np.pi * lj**2)) * (np.matmul(V, W))
            
            # construct P matrix for velocity at a point
            W = np.array([
                [(lj - xi) * phi + (eta * psi),       xi * phi - eta * psi],
                [eta * phi - (lj - xi) * psi - lj,  -eta * phi - xi * psi + lj]
                ])

            # build A
            A[i, j] += nx * P[1, 0] + ny * P[0, 0]
            A[i, (j + 1) ] += nx * P[1, 1] + ny * P[0, 1]

            if DEBUG and (i, j) in ((0,0), (0,1), (0,2)):
                print("\nDEBUG: influence of panel j={} on cp i={}".format(j, i))
                print(" panel j start (x,y) = ({:.12e}, {:.12e})".format(x[j], y[j]))
                print(" panel j end   (x,y) = ({:.12e}, {:.12e})".format(x[j+1], y[j+1]))
                print(" cp (x,y) = ({:.12e}, {:.12e})".format(xc[i], yc[i]))
                print(" panel length l_j = {:.12e}".format(lj))
                print("    xi = {:.15e}".format(xi))
                print("   eta = {:.15e}".format(eta))
                print("   psi = {:.15e}".format(psi))
                print("   phi = {:.15e}".format(phi))
                print("   M =\n", M)
                print("   N =\n", N)
                print("   P =\n", P)
    return A

A = build_A(x, y, xc, yc, dx, dy, l, DEBUG=False)
A[-1,:] = 0.0
A[-1,0] = 1.0
A[-1,-1] = 1.0


gamma = np.linalg.solve(A, B)

# Section lift 1.6.32
def calculate_lift_coefficient(l, gamma, c, V_inf):

    C_L = 0  # Initialize the lift coefficient 
    n = len(l)

    # Loop through each segment from i=0 to n-1
    for i in range(n):
        segment_contribution = (l[i] / c) * ((gamma[i] + gamma[i+1]) / V_inf)
        C_L += segment_contribution  # Add the segment's contribution to the total
    return C_L

# leading edge moment 
def calculate_moment(x, y, gamma, c, l, V_inf, a):
    for i in range(n):
        sx = 2*x[i]*gamma[i] + x[i]*gamma[i+1] + x[i+1]*gamma[i] +2*x[i+1]*gamma[i+1]
        sy = 2*y[i]*gamma[i] + y[i]*gamma[i+1] + y[i+1]*gamma[i] + 2*y[i+1]*gamma[i+1]
        panel_contribution = (l[i] / c) * ((sx * np.cos(a) / (V_inf*c)) + (sy* (np.sin(a)/(c*V_inf)))) #1.6.33
        C_mle += (-1/3) * panel_contribution
    return C_mle

"""
Strealine Formulation
"""

# velocity at a point
def calculate_velocity(V_inf, a):

    # initialize velocity field 
    u = np.full_like(X, V_inf*np.cos(a))
    v = np.full_like(Y, V_inf*n)
    # Panel geometry
    dx_panel = x[1:] - x[:-1]
    dy_panel = y[1:] - y[:-1]
    l_panel = np.sqrt(dx_panel**2 + dy_panel**2)

    # Add influence of each vortex panel to the velocity field
    for j in range(n_pan):
        dxj, dyj, lj = dx_panel[j], dy_panel[j], l_panel[j]
        
        # Transform grid points to the panel's local coordinate system
        N_x = X - x[j]
        N_y = Y - y[j]
        xi = (N_x * dxj + N_y * dyj) / lj
        eta = (-N_x * dyj + N_y * dxj) / lj

        # Calculate phi and psi (same formulas as in build_A)
        # Add a small epsilon to the denominator to avoid division by zero
        phi = np.arctan2(eta * lj, (eta**2 + xi**2 - xi * lj + 1e-12))
        psi = 0.5 * np.log(((xi**2 + eta**2) / ((xi - lj)**2 + eta**2 + 1e-12)) + 1e-12)

        # W matrix elements
        W11 = (lj - xi) * phi + eta * psi
        W12 = xi * phi - eta * psi
        W21 = eta * phi - (lj - xi) * psi - lj
        W22 = -eta * phi - xi * psi + lj
        
        # Calculate induced velocity components from this panel using the P matrix
        # and add them to the total velocity field

        u_induced = (1 / (2 * np.pi * lj**2)) * (
            (dxj*W11 - dyj*W21) * gamma[j] + (dxj*W12 - dyj*W22) * gamma[j+1]
        )
        v_induced = (1 / (2 * np.pi * lj**2)) * (
            (dyj*W11 + dxj*W21) * gamma[j] + (dyj*W12 + dxj*W22) * gamma[j+1]
        )

        v +=np.array([[ u_induced,
                       v_induced]])
        
    return v

v = calculate_velocity(V_inf, a)

def streamline(v):
    h = .1 # step
    sl = np.zerros[n]
    for i in range(n):
        #RK4 formulation
        k1 = np.linalg.norm(v[i, i]])
        k2 = np.linalg.norm(v[i+(h/2), i+(k1*h / 2)]])
        k3 = np.linalg.norm(v[i+(h/2), i+(k2*h / 2)]])
        k4 = np.linalg.norm(v[i+(h/2), i+(k3*h / 2)]])
        sl[i+1] += sl[i] + ((h/6) * (k1 + 2*k2 + 2*k3 + k4))

# plot streamlines
u_field = streamline(v)
v_field = streamline(v)

# Create a grid for the streamline plot
n_grid = 200
x_start, x_end = -0.5, 1.5
y_start, y_end = -.5, .5
X, Y = np.meshgrid(np.linspace(x_start, x_end, n_grid),
                   np.linspace(y_start, y_end, n_grid))

# mask airfoil area
airfoil_path = Path(np.vstack((x, y)).T)
mask = airfoil_path.contains_points(np.vstack((X.ravel(), Y.ravel())).T).reshape(X.shape)
u_field[mask] = np.nan
v_field[mask] = np.nan

print("Generating streamline plot...")
plt.style.use('seaborn-v0_8-whitegrid')
fig, ax = plt.subplots(figsize=(12, 9))

# Plot the airfoil shape
ax.fill(x, y, color='lightgray', edgecolor='black', linewidth=1, zorder=3)

# Plot the streamlines
magnitude = np.sqrt(u_field**2 + v_field**2)
ax.streamplot(X, Y, u_field, v_field, 
              density=2.5, 
              linewidth=0.5, 
              color=magnitude, 
              cmap='viridis',
              arrowsize=0.2)

# Formatting
ax.set_xlim(x_start, x_end)
ax.set_ylim(y_start, y_end)
ax.set_aspect('equal', adjustable='box')
ax.set_title(f'Streamlines around Airfoil at {np.degrees(a)}Â° Angle of Attack', fontsize=16)
ax.set_xlabel('x / c', fontsize=12)
ax.set_ylabel('y / c', fontsize=12)
plt.show()

"""
Calculation printouts
"""

C_L = calculate_lift_coefficient(l, gamma, c, V_inf)
print(f"Lift Coefficient: {C_L:.4f} ")

C_mle = calculate_moment(x, y, gamma, c, l, V_inf, a)
print(f"Leading-edge Moment Coefficient: {C_mle:.4f}")

C_qc = C_mle + (.25 * C_L)
print(f"Quarter Chord Moment Coefficient: {C_qc:.4f}")